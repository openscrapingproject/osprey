use serde::{Deserialize, Serialize};
use serde::de::DeserializeOwned;
// use serde_json::Value;

use anyhow::Error;

use async_trait::async_trait;

pub type AResult<T> = Result<T, Error>;

// pub type PluginID<'de> = &'de str;
pub type PluginID = String;
// pub trait Config: Box<dyn std::fmt::Debug + Sized> {}

// type Config = dyn DeserializeOwned;
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Plugin<Config> {
    pub plugin: PluginID,
    pub config: Config
}

// pub trait Parseable {
//     fn parse_config(self, config: Value) -> Self::Config;
// }

// Most of these plugins use associated types, so that our basic agent, which bakes the types of the plugins in for static dispatch, can be written with less duplication
pub trait BasicPlugin {
    type Config: Serialize + DeserializeOwned;
    
    // associated functions
    fn get_default_config() -> Self::Config;
    fn parse_config(input: serde_json::Value) -> AResult<Self::Config>;

    fn configure(&mut self, config: Self::Config) -> AResult<()>;
}

// Lesson learned: creating a trait for this is much more complicated than just a generic function
// It requires a crazy special type bound
// E.g. hoisting the type autogenerated by the derive macro. Not gonna happen


//  where C: self::_IMPL_DESERIALIZE_FOR_JobCollection::_serde::de::DeserializeOwned 
// impl<C> Parseable for Plugin<C>{
//     type Config = C;
//     fn parse_config(self, config: Value) -> Self::Config {
//         let x = serde_json::from_value::<Self::Config>(config).unwrap();
//         x
//     }
// }


// fn parse_config<RealConfig: Config>(input: Value) -> RealConfig {
//     let x = serde_json::from_value::<RealConfig>(input).unwrap();
//     x
// }

#[async_trait]
pub trait Requestor: BasicPlugin {
    type Response;
    async fn make_request(&self, url: &str) -> AResult<Self::Response>;
}

pub trait Matcher: BasicPlugin {
    type MatchInput;
    fn run_match(&self, data: Self::MatchInput) -> AResult<bool>;
}

pub trait Extractor: BasicPlugin {
    type Input;
    type Relevant: Serialize;
    // I represents input type
    // R represents Relevant data type
    fn extract(&self, input: Self::Input) -> AResult<Self::Relevant>;
}